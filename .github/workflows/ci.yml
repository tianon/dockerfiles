name: GitHub CI

on:
  pull_request:
  push:
  schedule:
    - cron: 0 0 * * 0

defaults:
  run:
    shell: 'bash -Eeuo pipefail -x {0}'

concurrency:
  group: ci-${{ github.ref }}
  cancel-in-progress: true

jobs:

  generate-jobs:
    name: Generate Jobs
    runs-on: ubuntu-latest
    outputs:
      strategy: ${{ steps.strategy.outputs.strategy }}
    env:
      BASHBREW_NAMESPACE: tianon
    steps:
      # TODO if it's a pull_request, we want to build only the changed things (generate sources.json before, generate after, only build the RHS/"comm -13" delta)
      - uses: actions/checkout@v4
      - uses: tianon/bashbrew@tianon
      - name: generate library
        run: |
          mkdir .library
          export BASHBREW_LIBRARY="$PWD/.library"
          printf 'BASHBREW_LIBRARY=%s\n' "$BASHBREW_LIBRARY" >> "$GITHUB_ENV"
          .github/workflows/gsls.sh
      - run: bashbrew fetch --all
      - name: checkout meta-scripts
        uses: actions/checkout@v4
        with:
          repository: tianon/doi-meta-scripts
          path: .meta-scripts
      # TODO handle external-pins better (in meta-scripts itself) -- perhaps an environment variable to explicitly opt-out of external-pins?
      - name: fake .external-pins (to satisfy sources.sh)
        run: install -D -m 0755 <(echo 'true') .external-pins/list.sh
      - name: sources.json
        run: .meta-scripts/sources.sh | tee sources.json
      - name: builds.json (fake)
        run: |
          jq -f .github/workflows/fake-builds.jq sources.json | tee builds.json
      - name: filter arches
        run: |
          # TODO refactor meta-scripts to pull the "arches GitHub Actions supports" list out of "Jenkinsfile.trigger"
          jq 'del(.[] | select(.build.arch as $arch | [ "amd64", "i386", "windows-amd64" ] | index($arch) | not))' builds.json | tee builds-filtered.json
          # TODO also calculate Windows GitHub "runs-on" OS values here so we can filter versions GitHub doesn't support here as well (there don't currently exist any of those in our data, so it doesn't matter ATM and we can deal with it later in the process)
      - name: groups
        run: |
          jq -f .github/workflows/group-builds.jq builds-filtered.json | tee groups.json
      - name: strategy
        id: strategy
        run: |
          jq -L .meta-scripts -f .github/workflows/strategy.jq groups.json | tee strategy.json
          jq -r '"strategy=\(tojson)"' strategy.json >> "$GITHUB_OUTPUT"

      # upload all the generated JSON files as a job artifact, for easier debugging
      - uses: actions/upload-artifact@v4
        with:
          name: debug meta-scripts generated json
          path: |
            *.json
          if-no-files-found: error

  test:
    needs: generate-jobs
    strategy: ${{ fromJson(needs.generate-jobs.outputs.strategy) }}
    name: ${{ matrix.name }}
    runs-on: ${{ matrix.runsOn }}
    env:
      commands: ${{ matrix.commands }}
      builds: ${{ toJSON(matrix.builds) }}
    steps:
      - name: meta
        run: |
          jq <<<"$builds" 'map(first(.source.arches[].tags[]) + " " + .build.arch)'
          cat <<<"$commands"
          jq <<<"$builds" .
      - name: prep docker (tianon-moby)
        uses: tianon/debian-moby-action@HEAD
        if: runner.os == 'linux' # https://github.com/tianon/dockerfiles/pull/523#issuecomment-1738223851
      - name: prep buildx
        run: |
          docker buildx create --name tianon --driver-opt image=tianon/buildkit --driver-opt network=host --bootstrap # network=host for access to "localhost:5000" (registry below)
          docker buildx inspect tianon
          echo 'BUILDX_BUILDER=tianon' >> "$GITHUB_ENV"
          echo 'BASHBREW_BUILDKIT_SYNTAX=tianon/buildkit' >> "$GITHUB_ENV"
        if: contains(matrix.commands, ' buildx ')
      - name: prep crane
        env:
          craneExe: crane${{ runner.os == 'windows' && '.exe' || '' }}
          craneUrl: https://doi-janky.infosiftr.net/job/wip/job/crane/lastSuccessfulBuild/artifact/crane-${{ runner.os == 'windows' && 'windows-amd64.exe' || 'amd64' }}
        run: |
          mkdir .bin
          curl -fL -o ".bin/$craneExe" "$craneUrl"
          chmod +x ".bin/$craneExe"
          ".bin/$craneExe" version
          echo "$PWD/.bin" >> "$GITHUB_PATH"
      - name: prep registry
        run: |
          rm -rf "$RUNNER_TEMP/registry"
          mkdir "$RUNNER_TEMP/registry"
          nohup crane registry serve --disk "$RUNNER_TEMP/registry" --address ':5000' &>> "$RUNNER_TEMP/registry.log" &
      # TODO use https://docs.github.com/en/actions/using-workflows/workflow-commands-for-github-actions#stopping-and-starting-workflow-commands to prevent builds from using workflow commands
      - name: run
        run: ${{ matrix.commands }}
      # TODO include running the tests (which means we might have to clone the local repo again, because it might have a .test/config.sh like mine does ðŸ™ˆ)
#      - name: Prepare Environment
#        run: ${{ matrix.runs.prepare }}
#      - name: Pull Dependencies
#        run: ${{ matrix.runs.pull }}
#      - name: Build ${{ matrix.name }}
#        run: ${{ matrix.runs.build }}
#      - name: History ${{ matrix.name }}
#        run: ${{ matrix.runs.history }}
#      - name: Test ${{ matrix.name }}
#        run: ${{ matrix.runs.test }}
#      - name: '"docker images"'
#        run: ${{ matrix.runs.images }}
